# ==================================================
# Path: /home/etheriaa/Documents/Code/amvn_oauth
# Detected tech: javascript
# ==================================================

## DIRECTORY STRUCTURE
```
amvn_oauth/
├── .git/
├── api/
│   └── chat.php
├── assets/
│   ├── bg1.jpg
│   ├── favicon.png
│   └── loading.gif
├── css/
│   └── style.css
├── js/
│   ├── chatbox.js
│   ├── consolelog.js
│   ├── index.js
│   ├── index.php
│   ├── session_manager.js
│   └── sidebar.js
├── .env
├── .gitignore
├── LICENSE
└── index.php
```

## FILE CONTENTS

### js/session_manager.js
```js
/**
 * Yuki Chat Session Manager
 * Handles logic for multiple chat sessions and rendering logic updates.
 */

window.YukiChat = {
    sessions: [],
    currentSessionId: null,
    
    init: function() {
        // Load sessions list
        this.sessions = JSON.parse(localStorage.getItem('yuki_sessions')) || [];
        
        // Load last active session or create new one
        const lastSessionId = localStorage.getItem('yuki_current_session_id');
        if (lastSessionId && this.sessions.find(s => s.id === lastSessionId)) {
            this.loadSession(lastSessionId);
        } else {
            this.newSession();
        }
    },

    newSession: function() {
        const newId = 'session_' + Date.now();
        const newSession = {
            id: newId,
            title: 'New Chat',
            timestamp: Date.now()
        };
        this.sessions.unshift(newSession); // Add to top
        this.saveSessions();
        this.loadSession(newId);
    },

    loadSession: function(sessionId) {
        this.currentSessionId = sessionId;
        localStorage.setItem('yuki_current_session_id', sessionId);
        
        // Dispatch event for sidebar to update active state
        window.dispatchEvent(new CustomEvent('yuki-session-changed', { detail: { id: sessionId } }));
        
        // Trigger chatbox UI reload
        // We need chatbox.js to listen to this or expose a reload method.
        if (window.reloadChatUI) {
            window.reloadChatUI(sessionId);
        }
    },

    saveMessage: function(role, text) {
        if (!this.currentSessionId) return;
        
        let history = this.getHistory(this.currentSessionId);
        history.push({ role: role, parts: [{ text: text }] });
        localStorage.setItem('yuki_history_' + this.currentSessionId, JSON.stringify(history));
        
        // Update Title if it's the first user message
        if (role === 'user' && history.length <= 2) { // 1 user msg, maybe 1 model greeting (if preserved)
             // Simple title logic: first 30 chars of message
             const session = this.sessions.find(s => s.id === this.currentSessionId);
             if (session && session.title === 'New Chat') {
                 this.renameSession(this.currentSessionId, text.substring(0, 30) + (text.length > 30 ? '...' : ''));
             }
        }
    },

    renameSession: function(sessionId, newTitle) {
        const session = this.sessions.find(s => s.id === sessionId);
        if (session) {
            session.title = newTitle;
            this.saveSessions();
        }
    },

    getSession: function(sessionId) {
        return this.sessions.find(s => s.id === sessionId);
    },

    getHistory: function(sessionId) {
        return JSON.parse(localStorage.getItem('yuki_history_' + sessionId)) || [];
    },

    saveSessions: function() {
        localStorage.setItem('yuki_sessions', JSON.stringify(this.sessions));
        window.dispatchEvent(new CustomEvent('yuki-sessions-updated'));
    },
    
    deleteSession: function(sessionId) {
        this.sessions = this.sessions.filter(s => s.id !== sessionId);
        this.saveSessions();
        localStorage.removeItem('yuki_history_' + sessionId);
        
        if (this.currentSessionId === sessionId) {
            this.newSession();
        } else {
            // Just update sidebar
            window.dispatchEvent(new CustomEvent('yuki-sessions-updated'));
        }
    }
};

```

### js/sidebar.js
```js
(function () {
    // --- CSS ---
    const style = document.createElement('style');
    style.innerHTML = `
        /* Sidebar container */
        #app-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 260px;
            height: 100vh;
            background: #151515;
            color: #e3e3e3;
            display: flex;
            flex-direction: column;
            z-index: 9000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            transition: width 0.3s ease; /* Animate width */
            box-shadow: 1px 0 10px rgba(0,0,0,0.3);
            overflow: hidden; /* Hide overflow content during transition */
        }

        #app-sidebar.collapsed {
            width: 70px;
        }

        /* Toggle Button */
        #sidebar-collapse-btn {
            background: transparent;
            border: none;
            color: #8e8e8e;
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            margin-right: 5px;
        }
        #sidebar-collapse-btn:hover { color: #fff; }

        /* Sidebar Header (New Chat) */
        .sidebar-header {
            padding: 20px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            white-space: nowrap;
        }
        
        .new-chat-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #282a2c;
            color: #e3e3e3;
            border: 1px solid transparent;
            border-radius: 20px;
            padding: 10px 15px;
            width: 100%;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            overflow: hidden;
        }
        .collapsed .new-chat-btn {
            justify-content: center;
            padding: 10px 0;
            width: 40px; /* Circle-ish */
            border-radius: 50%;
        }
        .collapsed .new-chat-btn span:last-child { display: none; } /* Hide text "New Chat" */
        
        .collapsed .sidebar-header {
            flex-direction: column-reverse; /* Put toggle button at bottom or adjust */
            gap: 10px;
            padding: 15px 10px;
        }

        /* Conversation List */
        .sidebar-nav {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 15px;
            overflow-x: hidden;
        }
        .nav-label {
            font-size: 12px;
            font-weight: 500;
            color: #8e8e8e;
            margin-bottom: 10px;
            margin-top: 10px;
            white-space: nowrap;
        }
        .collapsed .nav-label { display: none; }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            color: #e3e3e3;
            white-space: nowrap;
            overflow: hidden;
            transition: background 0.2s;
        }
        .collapsed .nav-item {
            justify-content: center;
            padding: 10px 0;
        }
        .collapsed .nav-item span:last-child { display: none; } /* Hide text */
        
        .nav-item:hover, .nav-item.active {
            background: #282a2c;
        }

        /* Sidebar Footer (Settings & Emotes) */
        .sidebar-footer {
            padding: 15px;
            border-top: 1px solid #333;
            display: flex;
            gap: 10px;
            flex-direction: column;
        }
        .collapsed .sidebar-footer {
            flex-direction: column;
            padding: 10px;
            gap: 5px;
        }

        .footer-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Align left */
            gap: 10px;
            background: transparent;
            border: none;
            color: #e3e3e3;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        /* Icon container for alignment */
        .footer-btn span:first-child {
            width: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .collapsed .footer-btn {
            justify-content: center; /* Center when collapsed */
        }
        .collapsed .footer-btn span:last-child { display: none; }
        
        .footer-btn:hover { background: #333; }

        /* --- Settings Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 11000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-overlay.open { display: flex; opacity: 1; }

        .modal-box {
            background: #1e1f20;
            width: 700px; /* Wider for 2 cols */
            max-width: 90%;
            height: 500px; /* Fixed height */
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', system-ui, sans-serif; /* Cleaner font */
        }
        .modal-overlay.open .modal-box { transform: scale(1); }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            background: #252627;
        }
        .modal-close { background: none; border: none; color: #aaa; font-size: 20px; cursor: pointer; }
        .modal-close:hover { color: #fff; }

        .modal-body {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        /* Left Category Sidebar */
        .settings-sidebar {
            width: 200px;
            background: #252627;
            border-right: 1px solid #333;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .settings-cat-btn {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #aaa;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        .settings-cat-btn:hover { background: #2f3133; color: #e3e3e3; }
        .settings-cat-btn.active { background: #2f3133; color: #fff; border-left-color: #00C6FF; font-weight: 500; }

        /* Right Content Area */
        .settings-content {
            flex-grow: 1;
            padding: 30px;
            overflow-y: auto;
            color: #e3e3e3;
        }
        .settings-section { display: none; animation: fadeIn 0.3s ease; }
        .settings-section.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .modal-section-title { font-size: 20px; font-weight: bold; margin-bottom: 20px; color: #fff; border-bottom: 1px solid #333; padding-bottom: 10px; }

        .bg-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
        .bg-option { height: 80px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; background-size: cover; background-position: center; transition: transform 0.2s; }
        .bg-option:hover { transform: scale(1.02); border-color: rgba(255,255,255,0.3); }
        .bg-option.selected { border-color: #00C6FF; box-shadow: 0 0 10px rgba(0, 198, 255, 0.3); }

        /* ... existing emote bar ... */
        #emote-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px); /* Hidden up top */
            background: rgba(30, 31, 32, 0.9);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            display: flex;
            gap: 10px;
            z-index: 10500;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #emote-bar.visible {
            transform: translateX(-50%) translateY(0);
        }

        .emote-btn {
            background: #333;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .emote-btn:hover { background: #444; transform: translateY(-2px); }
        .emote-btn:active { transform: scale(0.95); }

    `;
    document.head.appendChild(style);

    // --- HTML Structure ---

    // 1. Sidebar
    const sidebar = document.createElement('div');
    sidebar.id = 'app-sidebar';
    sidebar.innerHTML = `
        <div class="sidebar-header">
            <button id="sidebar-collapse-btn" title="Collapse Sidebar"><i class="bi bi-chevron-left"></i></button>
            <button class="new-chat-btn">
                <span><i class="bi bi-plus-lg"></i></span> <span>Đoạn chat mới</span>
            </button>
        </div>
        <div class="sidebar-nav">
            <div class="nav-label">Gần đây</div>
            <div class="nav-item active">
                <span><i class="bi bi-chat-dots-fill"></i></span> <span>Cuộc trò chuyện hiện tại</span>
            </div>
        </div>
        <div class="sidebar-footer">
            <button class="footer-btn" id="btn-settings" title="Settings">
                <span><i class="bi bi-gear-fill"></i></span> <span>Cài đặt</span>
            </button>
            <button class="footer-btn" id="btn-emotes" title="Emotes">
                <span><i class="bi bi-emoji-smile-fill"></i></span> <span>Biểu cảm</span>
            </button>
        </div>
    `;
    document.body.appendChild(sidebar);

    // 2. Settings Modal
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="modal-box">
            <div class="modal-header">
                <span>Settings</span>
                <button class="modal-close"><i class="bi bi-x-lg"></i></button>
            </div>
            <div class="modal-body">
                <div class="settings-sidebar">
                    <button class="settings-cat-btn active" data-target="sect-background"><i class="bi bi-image"></i> Appearance</button>
                    <button class="settings-cat-btn" data-target="sect-about"><i class="bi bi-info-circle"></i> About</button>
                </div>
                <div class="settings-content">
                    <div id="sect-background" class="settings-section active">
                        <div class="modal-section-title">Background</div>
                        <div class="bg-grid" id="bg-options-grid"></div>
                        <div style="margin-top: 15px; display: flex; gap: 10px;">
                            <input type="text" id="custom-bg-input" placeholder="Paste image URL..." style="flex: 1; padding: 10px; border-radius: 6px; border: 1px solid #444; background: #2a2a2a; color: #fff; font-size: 14px;">
                            <button id="btn-custom-bg" style="padding: 10px 20px; background: #00C6FF; border: none; border-radius: 6px; color: #fff; cursor: pointer; font-weight: 500;">Set</button>
                        </div>
                    </div>
                    
                    <div id="sect-about" class="settings-section">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <h2 style="margin: 0; color: #fff; font-weight: 700; letter-spacing: 1px;">Yuki Project</h2>
                            <p style="margin: 5px 0 0; color: #00C6FF; font-size: 13px;">Simply a hobbyist project.</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: 100px 1fr; gap: 10px; font-size: 14px;">
                                <div style="color: #888;">Version</div>
                                <div style="color: #eee;">0.36.18-alpha</div>
                                
                                <div style="color: #888;">Model</div>
                                <div style="color: #eee;">Vivian (<a href="https://booth.pm/en/items/7811941" style="color: #00C6FF; text-decoration: none;">Booth.pm</a>)</div>
                                
                                <div style="color: #888;">Engine</div>
                                <div style="color: #eee;">PixiJS + Live2D SDK</div>
                                
                                <div style="color: #888;">Chat AI</div>
                                <div style="color: #eee;">Gemini 2.0 Flash</div>
                                
                                <div style="color: #888;">TTS AI</div>
                                <div style="color: #eee;">Gemini 2.5 Flash TTS</div>
                            </div>
                        </div>

                        <div class="modal-section-title" style="font-size: 16px; margin-bottom: 10px;">Credits</div>
                        <p style="color: #aaa; font-size: 13px;">
                            Made with ❤️ by <a href="https://thanhcong2k7.auroramusicvietnam.net/" style="color: #00C6FF; text-decoration: none;">Etheriaa</a>.
                        </p>
                        <p style="color: #aaa; font-size: 13px; line-height: 1.6; margin-bottom: 5px;">
                            Hosted by <a href="https://auroramusicvietnam.net"><strong style="color: #fff;">Aurora Music Vietnam</strong></a>.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    // 3. Emote Bar
    const emoteBar = document.createElement('div');
    emoteBar.id = 'emote-bar';
    document.body.appendChild(emoteBar);

    // --- Logic ---

    // Render Session List
    function renderSessionList() {
        // Keep the "Recent" label
        const navContainer = document.querySelector('.sidebar-nav');
        navContainer.innerHTML = '<div class="nav-label">Recent</div>';

        const sessions = window.YukiChat ? window.YukiChat.sessions : [];
        const currentId = window.YukiChat ? window.YukiChat.currentSessionId : null;

        sessions.forEach(session => {
            const item = document.createElement('div');
            item.className = `nav-item ${session.id === currentId ? 'active' : ''}`;
            item.innerHTML = `
                <span><i class="bi bi-chat-dots-fill"></i></span>
                <span style="flex-grow: 1; overflow: hidden; text-overflow: ellipsis;">${session.title}</span>
                <button class="delete-chat-btn" style="background:none; border:none; color:#666; cursor:pointer; font-size:12px; display:none;">
                    <i class="bi bi-trash"></i>
                </button>
            `;

            // Hover to show delete
            item.addEventListener('mouseenter', () => {
                const delBtn = item.querySelector('.delete-chat-btn');
                if (delBtn) delBtn.style.display = 'block';
            });
            item.addEventListener('mouseleave', () => {
                const delBtn = item.querySelector('.delete-chat-btn');
                if (delBtn) delBtn.style.display = 'none';
            });

            // Click to load
            item.addEventListener('click', (e) => {
                if (e.target.closest('.delete-chat-btn')) {
                    e.stopPropagation();
                    if (confirm('Delete this chat?')) {
                        window.YukiChat.deleteSession(session.id);
                    }
                    return;
                }
                window.YukiChat.loadSession(session.id);
            });

            navContainer.appendChild(item);
        });
    }

    // New Chat Button
    const btnNewChat = document.querySelector('.new-chat-btn');
    btnNewChat.onclick = () => {
        if (window.YukiChat) window.YukiChat.newSession();
    };

    // Listen for Session Updates
    window.addEventListener('yuki-sessions-updated', renderSessionList);
    window.addEventListener('yuki-session-changed', renderSessionList);

    // Initial Render
    // We wait a bit to ensure YukiChat is loaded, though script order should handle it.
    setTimeout(renderSessionList, 100);

    // Load Settings from LocalStorage

    // Settings Navigation Logic
    const catBtns = document.querySelectorAll('.settings-cat-btn');
    const sections = document.querySelectorAll('.settings-section');

    catBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active from all
            catBtns.forEach(b => b.classList.remove('active'));
            sections.forEach(s => s.classList.remove('active'));

            // Add active to current
            btn.classList.add('active');
            document.getElementById(btn.dataset.target).classList.add('active');
        });
    });

    // Load Settings from LocalStorage
    function loadSettings() {
        // Sidebar State
        const isCollapsed = localStorage.getItem('yuki_sidebar_collapsed') === 'true';
        if (isCollapsed) {
            toggleSidebar(true);
        }

        // Background
        const savedBg = localStorage.getItem('yuki_bg_color');
        if (savedBg) {
            document.body.style.background = savedBg;
            document.body.style.backgroundSize = "cover";
        } else {
            document.body.style.background = 'url("./assets/bg1.jpg")';
            document.body.style.backgroundSize = "cover";
        }
    }

    // Toggle Sidebar Function
    const collapseBtn = document.getElementById('sidebar-collapse-btn');
    function toggleSidebar(forceCollapse = null) {
        const isCollapsed = forceCollapse !== null ? forceCollapse : !sidebar.classList.contains('collapsed');

        if (isCollapsed) {
            sidebar.classList.add('collapsed');
            collapseBtn.innerHTML = '<i class="bi bi-chevron-right"></i>';
        } else {
            sidebar.classList.remove('collapsed');
            collapseBtn.innerHTML = '<i class="bi bi-chevron-left"></i>';
        }

        // Save State
        localStorage.setItem('yuki_sidebar_collapsed', isCollapsed);

        // Trigger resize so Canvas adjusts
        window.dispatchEvent(new Event('resize'));
    }

    collapseBtn.addEventListener('click', () => toggleSidebar());

    // Settings Modal Logic
    const btnSettings = document.getElementById('btn-settings');
    const btnCloseModal = modal.querySelector('.modal-close');

    btnSettings.addEventListener('click', () => {
        modal.classList.add('open');
    });
    btnCloseModal.addEventListener('click', () => {
        modal.classList.remove('open');
    });
    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.classList.remove('open');
    });

    // Backgrounds
    const backgrounds = [
        { color: 'url("./assets/bg1.jpg")', name: 'Sakura' },
        { color: '#1a1a1a', name: 'Dark' },
        { color: '#f0f0f0', name: 'Light' },
        { color: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', name: 'Gradient 1' },
        { color: 'linear-gradient(to top, #30cfd0 0%, #330867 100%)', name: 'Gradient 2' }
    ];
    const bgGrid = document.getElementById('bg-options-grid');
    
    // Get current saved bg to highlight
    const currentSavedBg = localStorage.getItem('yuki_bg_color');
    // Default is Sakura if nothing saved
    const activeBg = currentSavedBg || 'url("./assets/bg1.jpg")';

    backgrounds.forEach(bg => {
        const div = document.createElement('div');
        div.className = 'bg-option';
        div.style.background = bg.color;
        div.title = bg.name;
        
        // Highlight active
        if (bg.color === activeBg) {
            div.classList.add('selected');
        }

        div.onclick = () => {
            document.body.style.background = bg.color;
            document.body.style.backgroundSize = "cover";
            document.querySelectorAll('.bg-option').forEach(el => el.classList.remove('selected'));
            div.classList.add('selected');
            localStorage.setItem('yuki_bg_color', bg.color);
        };
        bgGrid.appendChild(div);
    });

    // Custom Background Logic
    const btnCustomBg = document.getElementById('btn-custom-bg');
    const inputCustomBg = document.getElementById('custom-bg-input');
    btnCustomBg.addEventListener('click', () => {
        const url = inputCustomBg.value.trim();
        if (url) {
            const bgValue = `url("${url}")`;
            document.body.style.background = bgValue;
            document.body.style.backgroundSize = "cover";
            document.querySelectorAll('.bg-option').forEach(el => el.classList.remove('selected'));
            localStorage.setItem('yuki_bg_color', bgValue);
        }
    });

    // Emotes Logic
    const btnEmotes = document.getElementById('btn-emotes');
    let emoteTimeout;

    btnEmotes.addEventListener('click', () => {
        const bar = document.getElementById('emote-bar');
        bar.classList.toggle('visible');

        // Auto hide after 8 seconds if no interaction
        clearTimeout(emoteTimeout);
        if (bar.classList.contains('visible')) {
            emoteTimeout = setTimeout(() => {
                bar.classList.remove('visible');
            }, 8000);
        }
    });

    // Vivian Emotions (mapped from filenames)
    const emotions = [
        { name: 'Reset', file: null },
        { name: 'Cry', file: '哭' },
        { name: 'Shy', file: '害羞' },
        { name: 'Panic', file: '慌张' },
        { name: 'Roll Eyes', file: '白眼' },
        { name: 'Dark Face', file: '黑脸' },
        { name: 'Close Umbrella', file: '伞关闭' }
    ];

    emotions.forEach(emo => {
        const btn = document.createElement('button');
        btn.className = 'emote-btn';
        btn.innerText = emo.name;
        btn.onclick = () => {
            triggerExpression(emo.file);
            // Optional: Hide bar after selection
            // document.getElementById('emote-bar').classList.remove('visible');
        };
        emoteBar.appendChild(btn);
    });

    function triggerExpression(expName) {
        if (!window.model4) {
            console.warn("Model not loaded yet");
            return;
        }

        try {
            console.log("Attempting expression:", expName);

            if (expName === null) {
                // Reset is complex, usually we just set a neutral expression if exists
                // or we rely on the idle motion to take over.
                // There isn't a direct "clearExpression" in the high level API easily accessible without digging.
                console.log("Resetting expression...");
                // Just try setting an empty one or undefined
                window.model4.internalModel.motionManager.expressionManager.setExpression(0);
            } else {
                // Try 1: Direct name
                window.model4.expression(expName);

                // Debugging: List available expressions
                if (window.model4.internalModel && window.model4.internalModel.motionManager && window.model4.internalModel.motionManager.expressionManager) {
                    const definitions = window.model4.internalModel.motionManager.expressionManager.definitions;
                    console.log("Available Expressions:", definitions);
                }
            }
        } catch (e) {
            console.error("Expression Error:", e);
        }
    }

    // Global actions
    window.triggerExpression = triggerExpression;

    window.clearChat = function () {
        if (confirm("Start a new chat? This will clear current history.")) {
            localStorage.removeItem('yuki_chat_history');
            location.reload();
        }
    };

    // Resize helper for Canvas (updated from previous)
    // We attach this as a global function so index.js can access if needed, or index.js will read DOM
    window.getSidebarWidth = function () {
        return sidebar.classList.contains('collapsed') ? 70 : 260;
    };

    // Initialize
    loadSettings();

})();
```

### js/index.js
```js
const modelList = [
  'models/camellya/┤╗.model3.json',
  'models/vivian/薇薇安.model3.json',
  'models/huohuo/huohuo.model3.json',
  "models/Sylvir/Number1.model3.json"
];
// const cubism4Model = modelList[1];
const R2_ZIP_URL = 'https://assets.auroramusicvietnam.net/vivian.zip'; 

// GLOBAL VIRTUAL SERVER SETUP
const VIRTUAL_BASE_URL = 'http://localhost/virtual_model/';
const virtualFiles = new Map();

// Install Global XHR Interceptor
(function setupVirtualServer() {
    const originalXhrOpen = XMLHttpRequest.prototype.open;
    
    XMLHttpRequest.prototype.open = function(method, url, ...args) {
        // Only intercept requests to our virtual server
        if (typeof url === 'string' && url.startsWith(VIRTUAL_BASE_URL)) {
            // Normalize URL (handle encoding differences)
            let targetBlobUrl = virtualFiles.get(url);
            
            // If not found, try decoding
            if (!targetBlobUrl) {
                try {
                    targetBlobUrl = virtualFiles.get(decodeURI(url));
                } catch(e) {}
            }
            
            // If still not found, try encoding the suffix
            if (!targetBlobUrl) {
                 try {
                     const prefix = VIRTUAL_BASE_URL;
                     const suffix = url.substring(prefix.length);
                     const encodedSuffix = suffix.split('/').map(encodeURIComponent).join('/');
                     targetBlobUrl = virtualFiles.get(prefix + encodedSuffix);
                 } catch(e) {}
            }

            if (targetBlobUrl) {
                // console.log(`[VirtualServer] Serving: ${url}`);
                return originalXhrOpen.call(this, method, targetBlobUrl, ...args);
            } else {
                console.warn(`[VirtualServer] 404 Not Found: ${url}`);
            }
        }
        
        return originalXhrOpen.call(this, method, url, ...args);
    };
})();

let model4 = null;
let audioContext = null;
let analyser = null;
let dataArray = null;
let source = null;

function updateStatus(text, progress) {
    const textEl = document.getElementById('loading-text');
    const barEl = document.getElementById('progress-bar');
    if (textEl) textEl.textContent = text;
    if (barEl) barEl.style.width = `${progress * 100}%`;
}

async function fetchChunk(url, start, end, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, {
                headers: { 'Range': `bytes=${start}-${end}` }
            });
            if (!response.ok && response.status !== 206) {
                throw new Error(`Status ${response.status}`);
            }
            return await response.blob();
        } catch (e) {
            console.warn(`Chunk ${start}-${end} failed (attempt ${i+1}):`, e);
            if (i === retries - 1) throw e;
            await new Promise(r => setTimeout(r, 1000 * Math.pow(2, i))); // Exponential backoff
        }
    }
}

async function fetchWithChunks(url, onProgress) {
    // 1. Get total size
    const headRes = await fetch(url, { method: 'HEAD' });
    if (!headRes.ok) throw new Error(`HEAD failed: ${headRes.status}`);
    const totalSize = parseInt(headRes.headers.get('content-length') || '0', 10);
    if (!totalSize) throw new Error('Cannot determine file size');

    const chunkSize = 5 * 1024 * 1024; // 5MB
    const chunks = [];
    let loaded = 0;
    
    // 2. Download in chunks
    for (let start = 0; start < totalSize; start += chunkSize) {
        const end = Math.min(start + chunkSize - 1, totalSize - 1);
        const chunkBlob = await fetchChunk(url, start, end);
        chunks.push(chunkBlob);
        loaded += chunkBlob.size;
        onProgress(loaded / totalSize);
    }

    return new Blob(chunks);
}

async function loadZipModel(zipUrl) {
  try {
    updateStatus("Downloading assets...", 0.1);
    
    // Use fetchWithChunks for robust download
    const blob = await fetchWithChunks(zipUrl, (progress) => {
        // Download phase: 10% to 50%
        updateStatus(`Downloading... ${Math.round(progress * 100)}%`, 0.1 + (progress * 0.4));
    });

    updateStatus("Unpacking assets...", 0.55);
    const zip = await JSZip.loadAsync(blob);

    // Find the .model3.json file
    const filePaths = Object.keys(zip.files);
    const modelPath = filePaths.find(p => p.endsWith('.model3.json') || p.endsWith('.model.json'));
    if (!modelPath) throw new Error('No .model3.json or .model.json found in zip');

    const rootDir = modelPath.substring(0, modelPath.lastIndexOf('/') + 1);
    const files = {};

    updateStatus("Processing files...", 0.65);
    // Unzip all files to Blob URLs
    await Promise.all(filePaths.map(async path => {
      const file = zip.file(path);
      if (!file || file.dir) return;
      const b = await file.async('blob');
      // Create a blob URL for each file
      files[path] = URL.createObjectURL(b);
    }));

    updateStatus("Configuring model...", 0.8);
    // Parse the model JSON
    const modelJsonStr = await zip.file(modelPath).async('string');
    const modelJson = JSON.parse(modelJsonStr);

    // VIRTUAL SERVER STRATEGY
    // Set the model URL to our virtual server
    modelJson.url = VIRTUAL_BASE_URL + 'model.json';

    // 1. Populate Global Map of Virtual Paths to Blob URLs
    virtualFiles.clear(); // Clear previous model files if any
    
    const addToVirtualMap = (relativePath, blobUrl) => {
         const cleanPath = relativePath.startsWith('./') ? relativePath.slice(2) : relativePath;
         const virtualUrl = VIRTUAL_BASE_URL + cleanPath;
         
         // Store raw version
         virtualFiles.set(virtualUrl, blobUrl);
         
         // Store encoded version
         try {
             const encodedPath = cleanPath.split('/').map(encodeURIComponent).join('/');
             const virtualUrlEncoded = VIRTUAL_BASE_URL + encodedPath;
             if (virtualUrlEncoded !== virtualUrl) {
                 virtualFiles.set(virtualUrlEncoded, blobUrl);
             }
         } catch (e) { console.warn("Encoding error", e); }
         
         return virtualUrl;
    };
    
    for (const [zipPath, blobUrl] of Object.entries(files)) {
        if (zipPath.startsWith(rootDir)) {
            const relativePath = zipPath.substring(rootDir.length);
            addToVirtualMap(relativePath, blobUrl);
        }
    }

    // 2. Pre-load Textures into Pixi Cache
    if (modelJson.FileReferences && Array.isArray(modelJson.FileReferences.Textures)) {
        updateStatus("Loading textures...", 0.85);
        await Promise.all(modelJson.FileReferences.Textures.map(async (texPath) => {
            const cleanTexPath = texPath.startsWith('./') ? texPath.slice(2) : texPath;
            const virtualUrl = VIRTUAL_BASE_URL + cleanTexPath;
            
            // Try getting from map using raw or encoded
            let blobUrl = virtualFiles.get(virtualUrl);
            if (!blobUrl) {
                 const encodedPath = cleanTexPath.split('/').map(encodeURIComponent).join('/');
                 blobUrl = virtualFiles.get(VIRTUAL_BASE_URL + encodedPath);
            }
            
            if (blobUrl) {
                try {
                    const texture = await PIXI.Texture.fromURL(blobUrl);
                    PIXI.Texture.addToCache(texture, virtualUrl);
                    
                    const encodedPath = cleanTexPath.split('/').map(encodeURIComponent).join('/');
                    const encodedUrl = VIRTUAL_BASE_URL + encodedPath;
                    if (encodedUrl !== virtualUrl) {
                        PIXI.Texture.addToCache(texture, encodedUrl);
                    }
                } catch (e) {
                    console.warn("Failed to preload texture:", texPath, e);
                }
            } else {
                console.warn("Texture not found in zip:", texPath);
            }
        }));
    }

    // No need to set up XHR interceptor here anymore, it's global!

    updateStatus("Initializing Live2D...", 0.9);
    
    const model = await PIXI.live2d.Live2DModel.from(modelJson, { autoInteract: false });
    
    updateStatus("Ready!", 1.0);
    return model;

  } catch (e) {
    console.error("Failed to load model from zip:", e);
    updateStatus("Error loading model", 0);
    throw e;
  }
}

(async function main() {
  const app = new PIXI.Application({
    view: document.getElementById("canvas"),
    autoStart: true,
    resizeTo: window,
    transparent: true,
    backgroundAlpha: 0
  });
  
  // model4 = await PIXI.live2d.Live2DModel.from(cubism4Model);
  model4 = await loadZipModel(R2_ZIP_URL);
  
  window.model4 = model4;
  app.stage.addChild(model4);
  resizeModel(0.14);

  // Hide Loading Overlay
  const overlay = document.getElementById('loading-overlay');
  if(overlay) {
      overlay.classList.add('fade-out'); // Apply the class that triggers transition
      setTimeout(() => overlay.remove(), 1500); // Remove element after transition completes
  }

  app.ticker.add(() => {
    if (model4 && model4.internalModel && analyser && dataArray) {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      let count = 0;
      for (let i = 4; i < 100; i++) {
        sum += dataArray[i];
        count++;
      }
      let average = sum / count;
      if (average < 10) {
        average = 0;
      }
      const sensitivity = 60;
      let targetOpenness = average / sensitivity;
      targetOpenness = Math.pow(targetOpenness, 1.5);
      targetOpenness = Math.min(1.0, Math.max(0.0, targetOpenness));
      model4.internalModel.coreModel.setParameterValueById('ParamMouthOpenY', targetOpenness);
    }
  });

  model4.on("hit", (e) => {
    if (e.includes('body')) {
      console.log('hit');
      model4.motion('TapBody');
    }
  });
  
  // Enable interaction (PixiJS v6 uses 'interactive', not 'eventMode')
  model4.interactive = true;
  model4.cursor = 'pointer';
  model4.isHovering = false;

  model4.on('pointerover', () => { model4.isHovering = true; });
  model4.on('pointerout', () => { model4.isHovering = false; });

  model4.on('pointerdown', (e) => {
    model4.offsetX = e.data.global.x - model4.position.x;
    model4.offsetY = e.data.global.y - model4.position.y;
    model4.dragging = true;
  });

  model4.on('pointerup', () => {
    model4.dragging = false;
  });
  
  model4.on('pointerupoutside', () => {
    model4.dragging = false;
  });

  model4.on('pointermove', (e) => {
    // Make the model look at the mouse cursor
    model4.focus(e.data.global.x, e.data.global.y);
    
    if (model4.dragging) {
      model4.position.set(
        e.data.global.x - model4.offsetX,
        e.data.global.y - model4.offsetY
      );
    }
  });

  // Zoom with scroll wheel (only when hovering)
  window.addEventListener('wheel', (e) => {
    if (model4 && model4.isHovering) {
       // Determine zoom direction
       const zoomFactor = 1.1;
       let newScale = model4.scale.x;
       
       if (e.deltaY < 0) {
           // Zoom In
           newScale *= zoomFactor;
       } else {
           // Zoom Out
           newScale /= zoomFactor;
       }
       
       // Optional: Clamp scale to reasonable limits
       newScale = Math.min(Math.max(newScale, 0.05), 1.0);
       
       model4.scale.set(newScale);
    }
  });
})();
function resizeModel(scale) {
  if (!model4) return;
  // Dynamic sidebar width check
  const sidebarWidth = (typeof window.getSidebarWidth === 'function') ? window.getSidebarWidth() : 260;
  const chatboxWidth = 420; // Right chatbox width
  const availableWidth = window.innerWidth - sidebarWidth - chatboxWidth;
  
  model4.scale.set(scale);
  // Center in the available space between sidebar and chatbox
  model4.x = sidebarWidth + (availableWidth - model4.width) / 2;
  model4.y = (window.innerHeight - model4.height) / 2 + 100; // Keep vertical centering
}

// Re-trigger resize when sidebar toggles (listened via window resize or custom event if implemented)
window.addEventListener('resize', () => resizeModel(model4 ? model4.scale.x : 0.14));
window.connectAudioToLive2D = function (audioElement) {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 1024;
  analyser.smoothingTimeConstant = 0.5;
  const bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);
  if (source) {
    source.disconnect();
  }
  source = audioContext.createMediaElementSource(audioElement);
  source.connect(analyser);
  analyser.connect(audioContext.destination);
};
```

### js/consolelog.js
```js
(function () {
    // 1. Create and Inject Styles
    const style = document.createElement('style');
    style.innerHTML = `
        #debug-console-container {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 9999;
            box-sizing: border-box;
            pointer-events: none; /* Let clicks pass through empty areas */
        }

        #debug-console-toggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: #333;
            color: #fff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: auto;
            transition: transform 0.2s;
            z-index: 10001;
        }

        #debug-console-toggle:hover {
            transform: scale(1.1);
            background: #444;
        }

        #debug-console-main {
            background-color: rgba(30, 30, 30, 0.95);
            color: #d4d4d4;
            height: 300px; /* Default open height */
            width: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            border-top: 2px solid #444;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.5);
            pointer-events: auto;
        }

        #debug-console-header {
            background: #252526;
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            user-select: none;
        }

        #debug-console-header span {
            font-weight: bold;
            color: #aaa;
        }

        #debug-console-actions button {
            background: transparent;
            border: 1px solid #555;
            color: #ccc;
            cursor: pointer;
            margin-left: 5px;
            padding: 2px 8px;
            font-size: 11px;
            border-radius: 3px;
        }
        
        #debug-console-actions button:hover {
            background: #444;
        }

        #debug-console-output {
            flex: 1;
            overflow-y: auto;
            padding: 5px 0;
            scroll-behavior: smooth;
        }

        .log-entry {
            padding: 4px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .log-entry:hover {
            background-color: rgba(255,255,255,0.05);
        }

        /* Log Levels Colors */
        .log-type-log { color: #d4d4d4; }
        .log-type-info { color: #9cdcfe; background-color: rgba(156, 220, 254, 0.1); }
        .log-type-warn { color: #dcdcaa; background-color: rgba(220, 220, 170, 0.1); }
        .log-type-error { color: #f14c4c; background-color: rgba(241, 76, 76, 0.1); }
        .log-type-debug { color: #b5cea8; }

        .log-timestamp {
            color: #666;
            margin-right: 8px;
            font-size: 11px;
        }
    `;
    document.head.appendChild(style);

    // 2. Create HTML Structure
    const container = document.createElement('div');
    container.id = 'debug-console-container';
    container.innerHTML = `
        <div id="debug-console-toggle" title="Open Console">
            &gt;_
        </div>
        <div id="debug-console-main">
            <div id="debug-console-header">
                <span>Console Output</span>
                <div id="debug-console-actions">
                    <button id="btn-clear-console">Clear</button>
                    <button id="btn-close-console">Minimize</button>
                </div>
            </div>
            <div id="debug-console-output"></div>
        </div>
    `;
    document.body.appendChild(container);

    // 3. Logic & Event Listeners
    const toggleBtn = document.getElementById('debug-console-toggle');
    const mainWin = document.getElementById('debug-console-main');
    const outputDiv = document.getElementById('debug-console-output');
    const clearBtn = document.getElementById('btn-clear-console');
    const closeBtn = document.getElementById('btn-close-console');

    // UI Toggles
    toggleBtn.addEventListener('click', () => {
        mainWin.style.display = 'flex';
        toggleBtn.style.display = 'none';
        scrollToBottom();
    });

    closeBtn.addEventListener('click', () => {
        mainWin.style.display = 'none';
        toggleBtn.style.display = 'flex';
    });

    clearBtn.addEventListener('click', () => {
        outputDiv.innerHTML = '';
    });

    function scrollToBottom() {
        outputDiv.scrollTop = outputDiv.scrollHeight;
    }

    // 4. Intercept Console Methods
    const originalConsole = {
        log: console.log,
        info: console.info,
        warn: console.warn,
        error: console.error,
        debug: console.debug
    };

    function formatArgument(arg) {
        if (typeof arg === 'object' && arg !== null) {
            try {
                return JSON.stringify(arg, null, 2);
            } catch (e) {
                return '[Circular Object]';
            }
        }
        return String(arg);
    }

    function addLogEntry(type, args) {
        const entry = document.createElement('div');
        entry.className = `log-entry log-type-${type}`;

        const time = new Date().toLocaleTimeString([], { hour12: false });
        
        // Convert all arguments to strings/JSON and join them
        const message = Array.from(args).map(formatArgument).join(' ');

        entry.innerHTML = `<span class="log-timestamp">[${time}]</span> ${message.replace(/</g, "&lt;").replace(/>/g, "&gt;")}`;
        
        outputDiv.appendChild(entry);
        scrollToBottom();
    }

    // Proxy the console methods
    ['log', 'info', 'warn', 'error', 'debug'].forEach(method => {
        console[method] = function (...args) {
            // 1. Call the original console method (so it still shows in DevTools)
            originalConsole[method].apply(console, args);
            // 2. Add to our custom UI
            addLogEntry(method, args);
        };
    });

    // Optional: Capture unhandled errors
    window.addEventListener('error', function(event) {
        addLogEntry('error', [`[Uncaught Error] ${event.message} at ${event.filename}:${event.lineno}`]);
    });
    toggleBtn.click();
})();
```

### js/chatbox.js
```js
(function () {
    const API_ENDPOINT = 'api/chat.php';
    marked.setOptions({ breaks: true });
    const style = document.createElement('style');
    style.innerHTML = `
        #ai-widget-container { position: fixed; top: 20px; bottom: 20px; right: 20px; width: 420px; z-index: 10000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; pointer-events: none; display: flex; flex-direction: column; justify-content: flex-end; transition: all 0.3s ease; }
        #ai-widget-container.ai-minimized { top: auto; height: auto; }
        #ai-widget-box { background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); display: flex; flex-direction: column; overflow: hidden; pointer-events: auto; transition: all 0.3s ease; height: 100%; }
        .ai-minimized #ai-widget-box { height: auto; border-radius: 20px; background: transparent; box-shadow: none; border: none; overflow: visible; }
        .ai-minimized #ai-widget-input-area { background: rgba(20, 20, 20, 0.85); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 25px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
        #ai-widget-messages { flex-grow: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; scrollbar-width: thin; scrollbar-color: #555 transparent; }
        .ai-msg { max-width: 85%; padding: 12px 16px; border-radius: 18px; font-size: 15px; line-height: 1.5; color: #fff; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; overflow-x: auto; animation: popIn 0.3s ease-out; }
        .ai-msg img { max-width: 100%; height: auto; border-radius: 8px; }
        .ai-msg pre { max-width: 100%; overflow-x: auto; white-space: pre; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; }
        .ai-msg code { word-break: break-all; }
        .ai-msg-user { align-self: flex-end; background: linear-gradient(135deg, #007AFF, #00C6FF); border-bottom-right-radius: 4px; color: #fff; }
        .ai-msg-model { align-self: flex-start; background: rgba(255, 255, 255, 0.15); border-bottom-left-radius: 4px; }
        .ai-error { color: #ff6b6b; font-size: 13px; text-align: center; margin-top: 5px; font-style: italic; }
        #ai-widget-input-area { padding: 15px; display: flex; gap: 10px; background: rgba(0,0,0,0.3); border-top: 1px solid rgba(255,255,255,0.1); position: relative; }
        #ai-widget-input { flex-grow: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 25px; padding: 12px 20px; color: #fff; outline: none; font-size: 14px; transition: background 0.2s; }
        #ai-widget-input:focus { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.4); }
        .ai-btn { background: none; border: none; cursor: pointer; color: #fff; padding: 10px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background 0.2s; }
        .ai-btn:hover { background: rgba(255,255,255,0.2); }
        .ai-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .ai-btn svg { width: 22px; height: 22px; fill: currentColor; }
        .typing-indicator { display: flex; gap: 5px; padding: 12px 16px; background: rgba(255,255,255,0.1); border-radius: 18px; width: fit-content; align-self: flex-start; margin-bottom: 5px; border-bottom-left-radius: 4px; }
        .typing-dot { width: 8px; height: 8px; background: #ddd; border-radius: 50%; animation: typing 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; } .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing { 0%, 80%, 100% { transform: scale(0); opacity: 0.5; } 40% { transform: scale(1); opacity: 1; } }
        @keyframes popIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        #ai-widget-header {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; justify-content: space-between; align-items: center;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
        }
        .status-dot { width: 8px; height: 8px; background: #2ecc71; border-radius: 50%; display: inline-block; margin-right: 6px; box-shadow: 0 0 5px #2ecc71; }
        .status-text { font-size: 12px; color: #aaa; font-weight: normal; margin-left: 5px; }

        .ai-minimized #ai-widget-header, 
        .ai-minimized #ai-widget-messages,
        .ai-minimized #ai-file-preview { display: none !important; }
        
        #ai-btn-restore {
            display: none;
            position: absolute;
            top: -50px; /* Above the input bar */
            left: 50%;
            transform: translateX(-50%);
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: all 0.2s;
            z-index: 10001;
        }
        #ai-btn-restore:hover { background: #00C6FF; border-color: #00C6FF; }
        .ai-minimized #ai-btn-restore { display: flex !important; }
        
        #ai-btn-minimize { background: none; border: none; color: #ccc; cursor: pointer; font-size: 20px; line-height: 1; display: flex; align-items: center; }
        #ai-btn-minimize:hover { color: #fff; }
    `;
    document.head.appendChild(style);

    const container = document.createElement('div');
    container.id = 'ai-widget-container';
    container.innerHTML = `
        <div id="ai-widget-box">
            <div id="ai-widget-header">
                <div style="display: flex; align-items: center; flex-grow: 1; overflow: hidden; margin-right: 10px;">
                    <button id="ai-btn-edit-title" title="Rename" style="background:none; border:none; color:#aaa; margin-right:5px; cursor:pointer; font-size: 14px;"><i class="bi bi-pencil-fill"></i></button>
                    <span id="ai-widget-title" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: bold;">Yuki Chat</span>
                    <input id="ai-widget-title-input" type="text" style="display:none; background: rgba(0,0,0,0.2); border: 1px solid #555; color: white; border-radius: 4px; padding: 2px 5px; flex-grow: 1; min-width: 0; font-size: 14px;" autocomplete="off">
                    <span class="status-dot" style="margin-left: 10px; flex-shrink: 0;" title="Online"></span>
                </div>
                <button id="ai-btn-minimize" title="Minimize"><i class="bi bi-dash-lg"></i></button>
            </div>
            <div id="ai-widget-messages">
                <div class="ai-msg ai-msg-model">Chào cậu! Tớ là Yuki đây, cậu cần tớ giúp gì không nhỉ?</div>
            </div>
            <div id="ai-file-preview" style="display: none; padding: 10px 20px; font-size: 14px; color: #aaa; background: rgba(0,0,0,0.2); border-top: 1px solid rgba(255,255,255,0.05); cursor: pointer;"></div>
            
            <div id="ai-widget-input-area">
                <button id="ai-btn-restore" title="Restore"><i class="bi bi-chevron-up"></i></button>
                <input type="file" id="ai-widget-file-input" style="display: none;" accept="image/*, application/pdf">
                <button id="ai-btn-attach" class="ai-btn" title="Gửi ảnh/File">
                    <svg viewBox="0 0 24 24"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"/></svg>
                </button>
                <input type="text" id="ai-widget-input" placeholder="Nhập tin nhắn..." autocomplete="off">
                <button id="ai-btn-voice" class="ai-btn" title="Nói chuyện"><svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg></button>
                <button id="ai-btn-send" class="ai-btn" title="Gửi"><svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg></button>
            </div>
        </div>
    `;
    document.body.appendChild(container);
    
    // Toggle Minimize/Maximize Logic
    const btnMinimize = document.getElementById('ai-btn-minimize');
    const btnRestore = document.getElementById('ai-btn-restore');
    const widgetContainer = document.getElementById('ai-widget-container');

    if(btnMinimize) {
        btnMinimize.addEventListener('click', () => {
            widgetContainer.classList.add('ai-minimized');
        });
    }

    if(btnRestore) {
        btnRestore.addEventListener('click', () => {
            widgetContainer.classList.remove('ai-minimized');
        });
    }

    const input = document.getElementById('ai-widget-input');
    const msgContainer = document.getElementById('ai-widget-messages');
    const btnSend = document.getElementById('ai-btn-send');
    
    // --- Title Edit Logic ---
    const btnEditTitle = document.getElementById('ai-btn-edit-title');
    const titleSpan = document.getElementById('ai-widget-title');
    const titleInput = document.getElementById('ai-widget-title-input');

    btnEditTitle.addEventListener('click', () => {
        titleInput.value = titleSpan.innerText;
        titleSpan.style.display = 'none';
        titleInput.style.display = 'block';
        titleInput.focus();
    });

    const saveTitle = () => {
        const newTitle = titleInput.value.trim();
        if (newTitle && window.YukiChat && window.YukiChat.currentSessionId) {
            window.YukiChat.renameSession(window.YukiChat.currentSessionId, newTitle);
            titleSpan.innerText = newTitle;
        }
        titleInput.style.display = 'none';
        titleSpan.style.display = 'block';
    };

    titleInput.addEventListener('blur', saveTitle);
    titleInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') saveTitle();
    });

    let isProcessing = false;

    // --- INTEGRATION: Reload UI ---
    window.reloadChatUI = function(sessionId) {
        msgContainer.innerHTML = ''; // Clear current
        
        // Update Title
        if (window.YukiChat) {
            const session = window.YukiChat.getSession(sessionId);
            if (session) {
                titleSpan.innerText = session.title;
            }
        }

        const history = window.YukiChat.getHistory(sessionId);
        
        if (history.length === 0) {
            addMessage("Chào cậu! Tớ là Yuki đây, cậu cần tớ giúp gì không nhỉ?", 'model');
        } else {
            history.forEach(msg => {
                const text = msg.parts[0].text;
                addMessage(text, msg.role);
            });
        }
    };

    function addMessage(text, role) {
        const div = document.createElement('div');
        div.className = `ai-msg ai-msg-${role}`;
        div.innerHTML = marked.parse(text);
        msgContainer.appendChild(div);
        msgContainer.scrollTop = msgContainer.scrollHeight;
    }

    function base64ToArrayBuffer(base64) {
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }
    function createWavFile(audioData) {
        const sampleRate = 24000;
        const numChannels = 1;
        const bitsPerSample = 16;
        const wavHeader = new ArrayBuffer(44);
        const view = new DataView(wavHeader);
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + audioData.byteLength, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
        view.setUint16(32, numChannels * (bitsPerSample / 8), true);
        view.setUint16(34, bitsPerSample, true);
        writeString(view, 36, 'data');
        view.setUint32(40, audioData.byteLength, true);

        // Ghép Header + Data lại thành 1 file hoàn chỉnh
        return new Blob([wavHeader, audioData], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
    function playAudio(base64Data) {
        if (!base64Data) return;

        try {
            // 1. Stop old audio
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio = null;
            }

            // 2. Convert to WAV
            const pcmBuffer = base64ToArrayBuffer(base64Data);
            const wavBlob = createWavFile(pcmBuffer);
            const audioUrl = URL.createObjectURL(wavBlob);

            // 3. Create Audio Object
            const audio = new Audio(audioUrl);
            // IMPORTANT: Allow Cross Origin for Web Audio API
            audio.crossOrigin = "anonymous";
            window.currentAudio = audio;

            // 4. === INTEGRATION POINT ===
            // Call the function defined in index.js
            if (typeof window.connectAudioToLive2D === 'function') {
                window.connectAudioToLive2D(audio);
            }
            // ============================

            audio.play().catch(e => {
                console.error("Autoplay blocked:", e);
                addMessage("(Tap to listen)", "model");
            });

            // Visual effects
            const box = document.getElementById('ai-widget-box');
            box.style.borderColor = "rgba(100, 200, 255, 0.8)";

            // Optional: Trigger a random motion when talking starts
            // if (typeof model4 !== 'undefined') model4.motion('TapBody');

            audio.onended = () => {
                box.style.borderColor = "rgba(255, 255, 255, 0.1)";
                URL.revokeObjectURL(audioUrl);

                // Reset mouth to closed when done
                if (typeof model4 !== 'undefined' && model4.internalModel) {
                    model4.internalModel.coreModel.setParameterValueById('ParamMouthOpenY', 0);
                }
            };

        } catch (err) {
            console.error("Audio Error:", err);
        }
    }

    let typingEl = null;
    function showTyping(show) {
        if (show) {
            if (typingEl) return;
            typingEl = document.createElement('div');
            typingEl.className = 'typing-indicator';
            typingEl.innerHTML = `<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>`;
            msgContainer.appendChild(typingEl);
            msgContainer.scrollTop = msgContainer.scrollHeight;
            input.disabled = true;
            btnSend.disabled = true;
        } else if (typingEl) {
            typingEl.remove();
            typingEl = null;
            input.disabled = false;
            btnSend.disabled = false;
            input.focus();
        }
    }
    //
    // Attach file
    //
    const fileInput = document.getElementById('ai-widget-file-input');
    const btnAttach = document.getElementById('ai-btn-attach');
    const filePreview = document.getElementById('ai-file-preview');
    let currentFile = null; // Biến lưu file hiện tại

    // 1. Click nút kẹp giấy -> Mở hộp thoại chọn file
    btnAttach.addEventListener('click', () => fileInput.click());

    // 2. Khi người dùng chọn file
    fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
            currentFile = fileInput.files[0];
            filePreview.style.display = 'block';
            filePreview.innerHTML = `Đang chọn: ${currentFile.name} (Click để xóa)`;
            btnAttach.style.color = '#00C6FF'; // Đổi màu icon
        }
    });

    // 3. Xóa file nếu click vào tên file
    filePreview.addEventListener('click', () => {
        currentFile = null;
        fileInput.value = '';
        filePreview.style.display = 'none';
        btnAttach.style.color = '#fff';
    });

    // 4. Hàm helper chuyển file sang Base64
    const toBase64 = file => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
    });
    // Expression Mapping
    const expressionMap = {
        'cry': '哭',
        'shy': '害羞',
        'panic': '慌张',
        'rolleyes': '白眼',
        'angry': '黑脸',
        'reset': null // Reset to default
    };

    // --- MAIN FUNCTION ---
    async function sendMessage() {
        const text = input.value.trim();
        if (!text && !currentFile || isProcessing) return;
        
        let userMsgHTML = text;
        if (currentFile) {
            userMsgHTML += `<br><i>[Đính kèm: ${currentFile.name}]</i>`;
        }
        addMessage(userMsgHTML, 'user');
        
        // Save User Message
        window.YukiChat.saveMessage('user', text);

        filePreview.style.display = 'none';
        input.value = '';
        showTyping(true);
        isProcessing = true;

        let fileData = null;
        if (currentFile) {
            try {
                const base64String = await toBase64(currentFile);
                const parts = base64String.split(',');
                const mimeType = parts[0].match(/:(.*?);/)[1];
                const base64Data = parts[1];

                fileData = {
                    mimeType: mimeType,
                    data: base64Data
                };
            } catch (e) {
                console.error("Lỗi đọc file", e);
            }
            // Reset UI
            currentFile = null;
            fileInput.value = '';
            btnAttach.style.color = '#fff';
        }

        // Get current history for payload
        const currentHistory = window.YukiChat.getHistory(window.YukiChat.currentSessionId);

        try {
            const response = await fetch(API_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: text,
                    history: currentHistory, // Send full history
                    file: fileData
                })
            });

            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }

            const data = await response.json();
            showTyping(false);

            if (data.error) {
                addMessage("Lỗi từ Yuki: " + data.error, "model");
                return;
            }

            // Handle Expression
            if (data.expression && expressionMap.hasOwnProperty(data.expression)) {
                const expFile = expressionMap[data.expression];
                if (window.triggerExpression) {
                    window.triggerExpression(expFile);
                }
            }

            if (data.text) {
                addMessage(data.text, 'model');
                // Save Model Message
                window.YukiChat.saveMessage('model', data.text);
            } else {
                addMessage("... (Yuki gật đầu)", "model");
            }

            if (data.audio) {
                playAudio(data.audio);
            }

        } catch (error) {
            showTyping(false);
            addMessage(`<span class="ai-error">Mất kết nối với Yuki (${error.message})</span>`, "model");
            console.error("Chat Error:", error);
        } finally {
            isProcessing = false;
        }
    }

    // Event Listeners
    btnSend.addEventListener('click', sendMessage);
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !isProcessing) {
            sendMessage();
        }
    });

    // Voice Recognition (Giữ nguyên)
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.lang = 'vi-VN';
        recognition.continuous = false;
        recognition.interimResults = false;

        const btnVoice = document.getElementById('ai-btn-voice');

        recognition.onstart = () => {
            input.placeholder = "Đang nghe Yuki...";
            btnVoice.style.color = '#ff4b4b';
            btnVoice.style.animation = "pulse 1s infinite";
        };
        recognition.onend = () => {
            input.placeholder = "Nhập tin nhắn...";
            btnVoice.style.color = '#fff';
            btnVoice.style.animation = "none";
        };
        recognition.onresult = (e) => {
            const transcript = e.results[0][0].transcript;
            input.value = transcript;
            setTimeout(sendMessage, 500); // Tự động gửi sau 0.5s
        };

        btnVoice.onclick = () => {
            if (isProcessing) return;
            recognition.start();
        };
    } else {
        document.getElementById('ai-btn-voice').style.display = 'none'; // Ẩn nút mic nếu browser không hỗ trợ
    }
    
    // Initialize Session Manager
    if (window.YukiChat) {
        window.YukiChat.init();
    }

})();

```
